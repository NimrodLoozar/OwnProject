# Copilot Instructions

## Project Overview

This is a full-stack web application consisting of a FastAPI backend and React frontend with user authentication and role-based access control.

**Tech Stack:**

- **Backend**: FastAPI, SQLAlchemy, PostgreSQL/SQLite, JWT authentication, Python 3.11+
- **Frontend**: React 19, Vite, Ant Design, React Router DOM, SCSS/Sass
- **Authentication**: JWT tokens with role-based access (owner, user)
- **Database**: SQLAlchemy ORM with Alembic migrations

## Code Style & Conventions

### Python (Backend)

- Use **FastAPI** with async/await patterns where appropriate
- Follow **PEP 8** style guidelines
- Use **type hints** for all function parameters and return values
- Prefer **dependency injection** for database sessions and authentication
- Use **Pydantic models** for request/response schemas
- Keep **router files** focused on endpoint definitions
- Put **business logic** in separate service modules when complex

### JavaScript/React (Frontend)

- Use **functional components** with hooks (no class components)
- Prefer **const** over let/var, use **destructuring** for props and state
- Use **JSX** with proper component naming (PascalCase)
- Follow **React best practices** (proper useEffect dependencies, memoization when needed)
- Use **Ant Design components** consistently across the UI
- Keep **component files** under 300 lines, split larger components

### File Structure

- Backend routes go in `backend/app/routers/`
- Backend models in `backend/app/models/`
- Backend schemas in `backend/app/schemas/`
- Frontend components in `frontend/src/components/`
- Frontend pages in `frontend/src/pages/`
- Shared utilities in respective `utils/` directories

## Authentication & Security

- All API endpoints (except auth) require JWT authentication
- Use `get_current_user` dependency for protected routes
- Implement role-based access with `owner` having admin privileges
- Always validate user permissions before data modification
- Use password hashing with bcrypt via `get_password_hash`
- Store JWT tokens securely in client-side context

## Database Patterns

- Use SQLAlchemy declarative models with proper relationships
- Always use database sessions via dependency injection
- Handle database errors gracefully with try/except blocks
- Use Alembic for database schema migrations
- Implement soft deletes where appropriate (user management)

## API Design

- Follow RESTful conventions for endpoint naming
- Use appropriate HTTP status codes (200, 201, 404, 401, 403, etc.)
- Group related endpoints under router prefixes (`/api/auth`, `/api/users`, etc.)
- Include comprehensive error handling and validation
- Document endpoints with proper FastAPI metadata (title, description, tags)

## Frontend Patterns

- Use **AuthContext** for global authentication state management
- Implement **ProtectedRoute** component for authenticated-only pages
- Use **Ant Design** components for consistent UI/UX
- Handle loading states and error messages gracefully
- Implement responsive design (desktop and mobile layouts)
- Use **React Router** for client-side navigation

## Specific Requirements

### User Management

- Support user registration, login, logout
- Owner role can manage all users (view, delete, restore)
- Implement user profile updates and password changes
- Handle deleted users gracefully (redirect to deleted user page)

### UI/UX Guidelines

- Use Ant Design's design system consistently
- Implement responsive sidebar navigation (drawer on mobile)
- Show user role indicators (especially for owner)
- Provide clear feedback for user actions (success/error messages)
- Use SCSS for custom styling when Ant Design isn't sufficient

## Error Handling

- Backend: Use FastAPI's HTTPException with proper status codes
- Frontend: Implement global error boundaries and user-friendly error messages
- Log errors appropriately for debugging
- Validate all inputs on both client and server sides

## Performance Considerations

- Use React.memo() for components that re-render frequently
- Implement proper loading states for API calls
- Use database indexing for frequently queried fields
- Minimize bundle size by importing only needed Ant Design components

## Testing Guidelines

- Write unit tests for critical business logic
- Test authentication flows thoroughly
- Mock external dependencies in tests
- Test both positive and negative scenarios

## Docker & Deployment

### Container Architecture

- **Backend**: FastAPI app runs on Python 3.11 slim with uvicorn
- **Frontend**: Multi-stage build with Node.js build + Nginx serving
- **Database**: PostgreSQL 15 for production, SQLite for local development
- **Orchestration**: Docker Compose for service coordination

### Development Workflow

```bash
# Development with hot reload
docker-compose -f docker-compose.dev.yml up --build

# Production build
docker-compose up --build -d

# Rebuild specific service
docker-compose build backend
```

### Environment Configuration

- Use `.env.dev` for development containers
- Use `.env.prod` for production (update secrets!)
- Copy `.env.example` to `.env` for local development
- Never commit real `.env` files to version control

### Docker Best Practices

- Use multi-stage builds for frontend to minimize image size
- Implement proper health checks for all services
- Mount volumes for data persistence (PostgreSQL, SQLite)
- Use .dockerignore to exclude unnecessary files
- Set proper security headers in nginx configuration
- Use specific image tags instead of `latest` in production

## When Making Changes

1. **Database changes**: Create Alembic migrations
2. **API changes**: Update both router and schema files
3. **Authentication changes**: Test with different user roles
4. **UI changes**: Ensure responsive design works
5. **New features**: Follow established patterns and file structure
6. **Docker changes**: Test both dev and prod compose configurations

## Common Patterns to Follow

### API Endpoint Pattern

```python
@router.post("/endpoint", response_model=ResponseSchema)
async def create_something(
    data: RequestSchema,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Implementation
```

### React Component Pattern

```jsx
const ComponentName = ({ prop1, prop2 }) => {
  const [state, setState] = useState(initialValue);

  useEffect(() => {
    // Side effects
  }, [dependencies]);

  return <AntDComponent>{/* JSX */}</AntDComponent>;
};
```

### Error Handling Pattern (Frontend)

```jsx
try {
  const response = await api.call();
  // Handle success
} catch (error) {
  console.error("Error:", error);
  // Show user-friendly error message
}
```

Remember to maintain consistency with existing code patterns and always consider security implications when implementing new features.
