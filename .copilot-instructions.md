# Copilot Instructions

## Project Overview

This is a full-stack web application consisting of a FastAPI backend and React frontend with user authentication and role-based access control.

**Tech Stack:**

- **Backend**: FastAPI, SQLAlchemy, PostgreSQL/SQLite, JWT authentication, Python 3.11+
- **Frontend**: React 19.1.1, Vite, Ant Design, React Router DOM v7, SCSS/Sass
- **Authentication**: JWT tokens with role-based access (owner, user)
- **Database**: SQLAlchemy ORM with custom migration scripts
- **Theming**: Custom theme system with light/dark/system modes
- **Deployment**:
  - **Backend**: Docker containers on CasaOS with Portainer management
  - **Frontend**: Firebase Hosting
  - **Database**: PostgreSQL in Docker container
  - **Container Management**: Portainer for Docker stack management

## Code Style & Conventions

### Python (Backend)

- Use **FastAPI** with async/await patterns where appropriate
- Follow **PEP 8** style guidelines
- Use **type hints** for all function parameters and return values
- Prefer **dependency injection** for database sessions and authentication
- Use **Pydantic models** for request/response schemas
- Keep **router files** focused on endpoint definitions
- Put **business logic** in separate service modules when complex

### JavaScript/React (Frontend)

- Use **functional components** with hooks (no class components)
- Prefer **const** over let/var, use **destructuring** for props and state
- Use **JSX** with proper component naming (PascalCase)
- Follow **React best practices** (proper useEffect dependencies, memoization when needed)
- Use **Ant Design components** consistently across the UI
- Keep **component files** under 300 lines, split larger components

### File Structure

- Backend routes go in `backend/app/routers/`
- Backend models in `backend/app/models/`
- Backend schemas in `backend/app/schemas/`
- Backend utilities in `backend/app/utils/`
- Frontend components in `frontend/src/components/`
- Frontend pages in `frontend/src/pages/`
- Frontend contexts in `frontend/src/contexts/`
- Frontend assets in `frontend/src/assets/`
- Shared utilities in respective `utils/` directories
- Root-level Docker configurations and management scripts

## Authentication & Security

- All API endpoints (except auth) require JWT authentication
- Use `get_current_user` dependency for protected routes
- Implement role-based access with `owner` having admin privileges
- Always validate user permissions before data modification
- Use password hashing with bcrypt via `get_password_hash`
- Store JWT tokens securely in client-side context

## Database Patterns

- Use SQLAlchemy declarative models with proper relationships
- Always use database sessions via dependency injection
- Handle database errors gracefully with try/except blocks
- Use custom migration scripts in `backend/migrate*.py` for schema changes
- Implement soft deletes where appropriate (user management)
- Database files stored in `backend/data/` for SQLite, volumes for PostgreSQL

## API Design

- Follow RESTful conventions for endpoint naming
- Use appropriate HTTP status codes (200, 201, 404, 401, 403, etc.)
- Group related endpoints under router prefixes (`/api/auth`, `/api/users`, etc.)
- Include comprehensive error handling and validation
- Document endpoints with proper FastAPI metadata (title, description, tags)

### API Call Best Practices

- Use the `apiCall` helper from `AuthContext` for authenticated requests
- `apiCall` signature: `apiCall(endpoint, method = 'GET', body = null, customHeaders = {})`
- `apiCall` automatically handles authentication headers and error responses
- Always use try/catch when calling `apiCall` as it throws errors for failed requests
- Don't check `response.ok` - `apiCall` handles this and throws on failure

## Frontend Patterns

- Use **AuthContext** for global authentication state management
- Use **ThemeContext** for theme management (light/dark/system modes)
- Implement **ProtectedRoute** component for authenticated-only pages
- Use **Ant Design** components for consistent UI/UX
- Handle loading states and error messages gracefully
- Implement responsive design (desktop and mobile layouts)
- Use **React Router** for client-side navigation
- Use **SCSS/Sass** for custom styling when Ant Design isn't sufficient

### Navigation & Routing

- Use `useLocation` hook to track current route for active menu highlighting
- Implement dynamic `selectedKeys` on Menu components based on current pathname
- Always redirect users to dashboard ("/") after successful login using `useNavigate`
- Map routes to menu keys consistently:
  - "/" or "/dashboard" → key "1" (Dashboard)
  - "/about" → key "2" (About)
  - "/settings" → key "3" (Settings)
  - "/admin/users" → key "4" (Manage Users)
- Apply navigation patterns to both desktop sidebar and mobile drawer menus

### Theme System

- Use `ThemeContext` for global theme state management
- Support three theme modes: light, dark, system (follows OS preference)
- Implement `ThemeSelector` component for theme switching
- Use Ant Design's ConfigProvider for theme configuration
- Store theme preference in localStorage for persistence
- Apply theme changes dynamically across all components

## Specific Requirements

### User Management

- Support user registration, login, logout
- Owner role can manage all users (view, delete, restore)
- Implement user profile updates and password changes
- Handle deleted users gracefully (redirect to deleted user page)
- **Soft Delete System**: Users are marked as deleted rather than permanently removed
  - Deleted users have `deleted_at` timestamp and `deleted_by` user ID
  - Deleted users are excluded from active user lists and authentication
  - Owner can view, restore, or permanently delete soft-deleted users
  - Provides audit trail and recovery options for accidental deletions

### UI/UX Guidelines

- Use Ant Design's design system consistently
- Implement responsive sidebar navigation (drawer on mobile)
- Show user role indicators (especially for owner)
- Provide clear feedback for user actions (success/error messages)
- Use SCSS for custom styling when Ant Design isn't sufficient
- Include theme selector in appropriate UI locations
- Support system theme preference detection

## Error Handling

- Backend: Use FastAPI's HTTPException with proper status codes
- Frontend: Implement global error boundaries and user-friendly error messages
- Log errors appropriately for debugging
- Validate all inputs on both client and server sides

## Performance Considerations

- Use React.memo() for components that re-render frequently
- Implement proper loading states for API calls
- Use database indexing for frequently queried fields
- Minimize bundle size by importing only needed Ant Design components

## Testing Guidelines

- Write unit tests for critical business logic
- Test authentication flows thoroughly
- Mock external dependencies in tests
- Test both positive and negative scenarios

## Docker & Deployment

### Container Architecture

- **Backend**: FastAPI app runs on Python 3.11 slim with uvicorn
- **Frontend**: Multi-stage build with Node.js build + Nginx serving
- **Database**: PostgreSQL 15 for production, SQLite for local development
- **Orchestration**: Docker Compose for service coordination

### Development Workflow

```bash
# Using Makefile (recommended)
make dev          # Start development with hot reload
make dev-d        # Start development in background
make dev-logs     # Follow development logs
make prod         # Start production environment
make prod-logs    # Follow production logs

# Direct Docker Compose commands
docker-compose -f docker-compose.dev.yml up --build
docker-compose up --build -d
docker-compose build backend
```

### Environment Configuration

- Use `.env.example` as template for environment variables
- Use `.env.dev` for development containers
- Use `.env.prod` for production (update secrets!)
- Frontend uses `.env.development` and `.env.production` for build-specific configs
- Copy `.env.example` to `.env` for local development
- Never commit real `.env` files to version control
- Database stored in `backend/data/` directory for persistence

### Docker Best Practices

- Use multi-stage builds for frontend to minimize image size
- Implement proper health checks for all services
- Mount volumes for data persistence (PostgreSQL, SQLite)
- Use .dockerignore to exclude unnecessary files
- Set proper security headers in nginx configuration
- Use specific image tags instead of `latest` in production

### Deployment Options

- **Current Production Setup**:
  - **Backend**: Deployed on CasaOS as Docker containers managed by Portainer
  - **Frontend**: Deployed on Firebase Hosting
  - **Database**: PostgreSQL container on CasaOS
  - **Port Configuration**: Backend accessible on port 8001 externally (maps to 8000 internally)
- **Environment Configuration**:
  - **Development**: Uses `localhost:8000` for backend API
  - **Production**: Uses CasaOS local IP address (e.g., `192.168.x.x:8001`) for backend API
  - **Frontend Environment**: Firebase hosting with environment-specific API endpoints
- **Docker Deployment Files**:
  - `docker-compose.yml`: Standard development configuration
  - `docker-compose.dev.yml`: Development environment with hot reload
  - `docker-compose.casaos.yml`: CasaOS-specific configuration
  - `docker-compose.portainer.yml`: Portainer-optimized configuration
  - `docker-compose.full.yml`: Complete production setup
- **Management Tools**:
  - **Portainer**: Web UI for Docker container management on CasaOS
  - **Firebase CLI**: Frontend deployment and hosting management
  - **CasaOS**: Home server platform for container hosting

### Production Deployment Workflow

1. **Backend Updates**:
   - Code changes committed to Git repository
   - Use Portainer "Pull and redeploy" to update containers
   - Backend rebuilds automatically from source using Docker build context
2. **Frontend Updates**:
   - Update environment variables in `.env.production` if needed
   - Run `npm run build` to create production build
   - Deploy to Firebase using `firebase deploy`
3. **Database Migrations**:
   - Access backend container via Portainer console
   - Run migration scripts: `python migrate_profile_fields.py`, `python migrate_theme_system.py`

### Network Configuration

- **Backend Access**:
  - Internal (container): `localhost:8000`
  - External (from frontend): `http://casaos-ip:8001/api`
  - Health check: `http://casaos-ip:8001/health`
  - API docs: `http://casaos-ip:8001/docs`
- **CORS Configuration**: Backend allows all origins (`allow_origins=["*"]`) for development
- **Port Mapping**: Container port 8000 mapped to host port 8001

## When Making Changes

1. **Database changes**: Run custom migration scripts (`backend/migrate*.py`) via Portainer console
2. **API changes**: Update both router and schema files, then redeploy via Portainer
3. **Authentication changes**: Test with different user roles, ensure CORS allows Firebase domain
4. **UI changes**: Ensure responsive design works across themes, test with production API endpoints
5. **Theme changes**: Test in light, dark, and system modes
6. **New features**: Follow established patterns and file structure
7. **Backend deployment**: Use Portainer "Pull and redeploy" to update containers with latest Git changes
8. **Frontend deployment**: Update environment variables if needed, then `firebase deploy`
9. **Environment changes**: Update appropriate `.env` files and redeploy affected services
10. **Network configuration**: Ensure API endpoints use correct CasaOS IP and port (8001) for production

## Troubleshooting Common Issues

### Backend Deployment Issues

- **Docker pull errors**: Ensure `docker-compose.casaos.yml` uses `build:` context instead of `image:` for custom images
- **Port conflicts**: Verify backend is accessible on port 8001, not 8000 in production
- **Container health**: Check Portainer logs for backend container startup issues

### Frontend Connectivity Issues

- **"Failed to fetch" errors**: Check API endpoint configuration in `.env.production`
- **CORS errors**: Verify backend CORS settings allow Firebase hosting domain
- **Network access**: Ensure CasaOS backend is accessible from external networks (port forwarding if needed)

### Environment Configuration

- **Development**: `VITE_API_BASE_URL=http://localhost:8000/api`
- **Production**: `VITE_API_BASE_URL=http://[casaos-ip]:8001/api`
- **Health check**: Always test `/health` endpoint after deployment changes

## Common Patterns to Follow

### API Endpoint Pattern

```python
@router.post("/endpoint", response_model=ResponseSchema)
async def create_something(
    data: RequestSchema,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Implementation
```

### Theme System Pattern

```jsx
// Using ThemeContext
const MyComponent = () => {
  const { themeMode, setTheme, loading } = useTheme();

  const handleThemeChange = (newTheme) => {
    setTheme(newTheme); // 'light', 'dark', or 'system'
  };

  return (
    <ThemeSelector size="default" showLabels={true} direction="horizontal" />
  );
};

// Theme-aware component styling
const getThemeStyles = (themeMode) => ({
  background: themeMode === "dark" ? "#141414" : "#ffffff",
  color: themeMode === "dark" ? "#ffffff" : "#000000",
});
```

### Authentication & Navigation Pattern

```jsx
// Login component with redirect
const Login = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleLogin = async (values) => {
    try {
      await login(username, password);
      navigate("/"); // Always redirect to dashboard after login
    } catch (error) {
      // Handle error
    }
  };
};
```

### Navigation Menu Pattern

```jsx
// App component navigation
const AppContent = () => {
  const location = useLocation();

  const getSelectedKey = () => {
    const pathname = location.pathname;
    if (pathname === "/" || pathname === "/dashboard") return "1";
    if (pathname === "/about") return "2";
    if (pathname === "/settings") return "3";
    if (pathname === "/admin/users") return "4";
    return "1"; // Default to dashboard
  };

  return (
    <Menu
      theme="dark"
      mode="inline"
      selectedKeys={[getSelectedKey()]} // Dynamic selection
      items={menuItems}
    />
  );
};
```

### React Component Pattern

```jsx
const ComponentName = ({ prop1, prop2 }) => {
  const [state, setState] = useState(initialValue);

  useEffect(() => {
    // Side effects
  }, [dependencies]);

  return <AntDComponent>{/* JSX */}</AntDComponent>;
};
```

### API Call Pattern

```jsx
// Correct usage of apiCall from AuthContext
const MyComponent = () => {
  const { apiCall } = useAuth();

  const handleDelete = async (id) => {
    try {
      // apiCall automatically handles authentication and throws errors for failed requests
      await apiCall(`/admin/users/${id}`, "DELETE");
      // Success - update UI
      console.log("Delete successful");
    } catch (error) {
      // Handle error - apiCall already parsed error message
      console.error("Delete failed:", error.message);
    }
  };

  const handleUpdate = async (id, data) => {
    try {
      const result = await apiCall(`/users/${id}`, "PUT", data);
      // Success - result contains parsed JSON response
      return result;
    } catch (error) {
      console.error("Update failed:", error.message);
    }
  };
};
```

### Error Handling Pattern (Frontend)

```jsx
try {
  const response = await api.call();
  // Handle success
} catch (error) {
  console.error("Error:", error);
  // Show user-friendly error message
}
```

## Soft Delete Implementation

### Database Schema

- **Model Fields**:
  - `deleted_at`: DateTime field (nullable) - timestamp when user was deleted
  - `deleted_by`: Integer field (nullable) - ID of the owner who deleted the user
- **Migration**: Use custom migration script `migrate_soft_delete.py` to add fields without data loss
- **Indexing**: Index `deleted_at` field for efficient querying of active/deleted users

### Backend API Patterns

#### Soft Delete Pattern
```python
@router.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    permanent: bool = False,  # Optional query param for permanent delete
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_owner)
):
    user = db.query(User).filter(User.id == user_id).first()
    if permanent:
        db.delete(user)  # Hard delete
    else:
        user.deleted_at = datetime.utcnow()  # Soft delete
        user.deleted_by = current_user.id
    db.commit()
```

#### Restore User Pattern
```python
@router.post("/users/{user_id}/restore")
async def restore_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_owner)
):
    user = db.query(User).filter(
        User.id == user_id,
        User.deleted_at.isnot(None)  # Only restore deleted users
    ).first()
    user.deleted_at = None
    user.deleted_by = None
    db.commit()
```

#### Query Active Users Pattern
```python
# Exclude soft-deleted users from queries
active_users = db.query(User).filter(User.deleted_at.is_(None)).all()

# Get only deleted users
deleted_users = db.query(User).filter(User.deleted_at.isnot(None)).all()

# Include deleted users (optional parameter)
@router.get("/users")
async def get_users(include_deleted: bool = False):
    query = db.query(User)
    if not include_deleted:
        query = query.filter(User.deleted_at.is_(None))
    return query.all()
```

### Frontend Patterns

#### DeletedUsersPage Component
```jsx
const DeletedUsersPage = () => {
  const [deletedUsers, setDeletedUsers] = useState([]);
  const { apiCall } = useAuth();

  const fetchDeletedUsers = async () => {
    const data = await apiCall("/admin/users/deleted", "GET");
    setDeletedUsers(data);
  };

  const handleRestore = async (userId) => {
    await apiCall(`/admin/users/${userId}/restore`, "POST");
    fetchDeletedUsers(); // Refresh list
  };

  const handlePermanentDelete = async (userId) => {
    await apiCall(`/admin/users/${userId}?permanent=true`, "DELETE");
    fetchDeletedUsers(); // Refresh list
  };

  return (
    <Table
      dataSource={deletedUsers}
      columns={[
        { title: "Username", dataIndex: "username" },
        { title: "Email", dataIndex: "email" },
        { title: "Deleted At", dataIndex: "deleted_at" },
        { title: "Deleted By", dataIndex: "deleted_by" },
        {
          title: "Actions",
          render: (_, record) => (
            <>
              <Button onClick={() => handleRestore(record.id)}>Restore</Button>
              <Popconfirm onConfirm={() => handlePermanentDelete(record.id)}>
                <Button danger>Permanent Delete</Button>
              </Popconfirm>
            </>
          ),
        },
      ]}
    />
  );
};
```

### Authentication Integration

- **User Session Validation**: `check_user_exists` should verify `deleted_at is None`
- **Login Prevention**: Block login attempts for soft-deleted users
- **Token Validation**: `get_current_user` must exclude users where `deleted_at is not None`
- **Auto-Logout**: Frontend `checkUserExists` interval should logout if user is deleted

### Migration Strategy

1. **Phase 1**: Add new fields with migration script
2. **Phase 2**: Update authentication logic to respect deleted_at
3. **Phase 3**: Convert delete endpoint to soft delete
4. **Phase 4**: Add restore and list deleted endpoints
5. **Phase 5**: Build frontend interface for deleted users management

### Best Practices

- Always filter by `deleted_at.is_(None)` for active user queries
- Provide both soft delete and permanent delete options for owners
- Log deletion and restoration events for audit purposes
- Consider adding `deleted_reason` field for documentation
- Implement automatic permanent deletion after retention period (e.g., 90 days)
- Show "deleted by" user information in admin interfaces
- Use confirmation dialogs for both restore and permanent delete actions

## Navigation & UI Fixes Implemented

### Active Menu State Fix

- **Issue**: Navigation menu always showed "Dashboard" as active regardless of current page
- **Solution**: Replaced `defaultSelectedKeys` with dynamic `selectedKeys` based on `useLocation`
- **Implementation**: Created `getSelectedKey()` function to map current pathname to menu keys
- **Applied to**: Both desktop sidebar and mobile drawer menus

### Login Redirect Fix

- **Issue**: Users remained on current page after logging in instead of going to dashboard
- **Solution**: Added `useNavigate` hook to Login component to redirect to "/" after successful login
- **Result**: Consistent user experience - all logins now lead to dashboard

### User Deletion API Fix

- **Issue**: User deletion failed with "'[object Object]' is not a valid HTTP method" error
- **Root Cause**: Incorrect `apiCall` usage - passing `{method: "DELETE"}` object instead of `"DELETE"` string
- **Solution**: Fixed API call from `apiCall(endpoint, {method: "DELETE"})` to `apiCall(endpoint, "DELETE")`
- **Additional Fix**: Removed unnecessary `response.ok` check since `apiCall` throws errors automatically
- **Result**: User deletion now works correctly for owner users

### Owner-Only Deleted Users Access

- **Implementation**: Created `OwnerRoute` component for role-based route protection
- **Component**: `OwnerRoute` checks authentication and owner role, redirects non-owners to dashboard
- **Route**: Added `/admin/deleted-users` protected by `OwnerRoute`
- **Navigation**: Added "Deleted Users" menu item with `UserDeleteOutlined` icon for owners only
- **Key Mapping**: Route key "5" for `/admin/deleted-users` in menu selection logic

## Project Management & Tools

### Available Scripts and Commands

- **Makefile**: Root-level Docker management commands (`make dev`, `make prod`, etc.)
- **Migration Scripts**: Custom database migration scripts in `backend/migrate*.py`
- **Firebase Deployment**: Configured for frontend hosting via `firebase.json`
- **Environment Templates**: `.env.example` with all required variables documented

### Development Tools

- **Hot Reload**: Both frontend (Vite) and backend (uvicorn) support hot reload in dev mode
- **Linting**: ESLint configured for frontend with React-specific rules
- **Multiple Deployment Targets**: Docker Compose files for different environments
- **Database Management**: SQLite for development, PostgreSQL for production

### Component Structure

- **Core Components**: `Login`, `ProtectedRoute`, `ErrorBoundary`, `ThemeSelector`
- **Context Providers**: `AuthContext`, `ThemeContext` for global state management
- **Page Components**: `HomePage`, `Dashboard`, `AboutPage`, `SettingsPage`, `AdminUsersPage`, `DeletedUserPage`
- **Styling**: Mix of Ant Design components and custom SCSS for enhanced styling

Remember to maintain consistency with existing code patterns and always consider security implications when implementing new features.
